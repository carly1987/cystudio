{
  "name": "webot",
  "version": "0.1.9",
  "repository": {
    "type": "git",
    "url": "git://github.com/node-webot/webot.git"
  },
  "description": "An easy-to-use robot for web service.",
  "author": {
    "name": "Jesse Yang",
    "email": "kissmud@gmail.com",
    "url": "https://github.com/ktmud"
  },
  "dependencies": {
    "debug": "0.7.x"
  },
  "devDependencies": {
    "mocha": "~1.13.0",
    "should": "~2.0.1",
    "async": "~0.2.9"
  },
  "engines": {
    "node": ">=0.6.0",
    "npm": ">=1.1.6"
  },
  "keywords": [
    "robot",
    "webot",
    "wechat",
    "weixin",
    "express"
  ],
  "scripts": {
    "test": "./node_modules/.bin/mocha"
  },
  "license": "MIT",
  "contributors": [
    {
      "name": "Jesse Yang",
      "email": "jyyjcc@gmail.com"
    },
    {
      "name": "TZ",
      "email": "atian25@qq.com"
    },
    {
      "name": "Jackson Tian",
      "email": "shyvo1987@gmail.com"
    },
    {
      "name": "yyfrankyy",
      "email": "yyfrankyy@gmail.com"
    }
  ],
  "readme": "# node webot [![Build Status](https://api.travis-ci.org/node-webot/webot.png?branch=master)](https://travis-ci.org/node-webot/webot)\n\nA web robot for node.js.\n\nWith simple rules based on RegExp and custom functions,\nyou can easily run a robot as web service.\n\n## Quick Start\n\n```javascript\nvar express = require('express');\nvar webot = require('webot');\n\nvar app = express();\n\nwebot.set('hi', \"Hi, I'm Webot.\");\n\nwebot.set('subscribe', {\n  pattern: function(info) {\n    return info.event === 'subscribe';\n  },\n  handler: function(info) {\n    return 'Thank you for subscribe.';\n  }\n});\n\napp.get('/webot', function(req, res, next) {\n  var message = req.query.message;\n\n  webot.reply({\n    text: message,\n  }, function(err, info) {\n    if (err) return res.json({ r: err });\n    res.json({\n      r: 0,\n      reply: info.reply\n    });\n  });\n});\n\n```\n\n# API Referrence\n\n## Webot\n\n### webot.set(pattern, handler, _[, replies]_)\n\nAdd new reply rule.\n\n```javascript\nwebot.set(pattern, handler, replies)\n\n// or\n\nwebot.set({\n  name: 'rule name',\n  pattern: function(info) { ... },\n  handler: function(info, next) {\n  }\n})\n```\n\n我们建议你给每条规则都命名，以方便规则之间互相调用。\n\n```javascript\nwebot.set('rule A', {\n  pattern: /ruleA/,\n  handler: function() {\n  },\n});\n\n// webot.get('rule A') 即可获得刚才定义的规则\n\n// 可以省略第二个参数里的 pattern ,\n// 则规则名会被转换为一个用于匹配的正则\nwebot.set('你好', function() {\n  // 随机回复一句话\n  return ['你也好', '你好', '很高兴认识你'];\n});\n\n// 更简单地\nwebot.set('你好', ['你也好', '你好', '很高兴认识你']);\n\n// 如果 handler 是一个 object ，也会直接作为 reply 返回\nwebot.set('test music message', {\n  type: 'music',\n  url: 'http://example.com/a.mp3'\n});\n```\n\n你甚至还可以直接传入一个 Object ，\n其 key 为 pattern ， value 为 handler\n（只要里面不包括 'handler' 这个 key）：\n\n```javascript\nwebot.set({\n  '你好':  function() {\n    // 随机回复一句话\n    return ['你也好', '你好', '很高兴认识你'];\n  },\n  '你是谁': '我是你的小天使呀'\n});\n```\n\n你可以根据rule的名字动态的删除一个rule，\n```javascript\nwebot.delete('rule1');\n```\n\n你可以根据rule的名字动态的更新rule，参数和set方法的参数一致\n```javascript\nrobot.update('rule1', {\n  pattern: 'hello',\n  handler: function(info) {\n    info.reply = 'hello';\n  }\n});\n```\n\n有关 `replies` 的使用，请参考 [rule.replies](#optionsreplies) 。\n\n### webot.get(ruleName)\n\nGet a rule based on its name. `ruleName` must be a string.\n\n### webot.waitRule(name, [handler])\n\nSet a wait rule for `info.wait` to use. Must provide a valid `name`.\nIf handler not presented, try get the wait rule with that name.\n\n`等待规则` 即只在等待用户回复时才执行的规则。\n\n### webot.beforeReply(handler)\n\nAdd a preprocess rule. `rule.handler` will be called every time before checking reply rules.\n\n预处理规则，可以对发来的消息进行预处理，比如从数据库取出用户等。\n\n```\nwebot.beforeReply(function load_user(info, next) {\n  User.get(info.uid, function(err, user) {\n    if (err) return next(err);\n    info.user = user; // attach this user object to Info.\n    next();\n  });\n});\n```\n\n### webot.afterReply()\n\nAdd a post-repy rule. `rule.handler` will be called every time after a reply is got.\n\n获得回复内容或对消息再处理，比如[简繁转化](https://github.com/node-webot/webot-douban-event/blob/master/app.js#L72)。\n\n\n### webot.domain(pattern, handler, replies)\n\nAdd domain specified rule, middlewares for groups of rules.\n\nExample:\n\n```javascript\nwebot.domain('domain-1', function require_user(info) {\n  if (!info.user) {\n    return 'Must login first';\n  }\n});\n\nwebot.set('domain-1 act-1', {\n  domain: 'domain-1',\n  pattern: /some pattern/,\n  handler: function()..\n});\n\nwebot.set('domain-1 act-2', {\n  domain: 'domain-1',\n  pattern: /another pattern/,\n  handler: function()..\n});\n```\n\nSo when `/some pattern/` and `/another pattern/` is matched, webot will run into the `domain-1` middleware first,\nto check whether user is logged in.\n\n### webot.loads(file1, _[file2, ...]_)\n\n载入 nodejs 模块作为 webot 的回复规则，以方便你在比较复杂的项目中组织文件。\n\nfile1, file2 是相对于调用此方法的文件所在目录的文件名。\n\n\n```javascript\nwebot.loads('./rules/a', './rules.b');\n```\n\nIn file `./rules/a.js` and `./rules/b.js`:\n\n```javascript\nmodule.exports = function(webot) {\n  webot.set('rule_a', function(info, next) {\n    // ...\n  });\n  webot.set('rule_a_1', 'some reply');\n};\n```\n\nor use single Rule defination:\n\n```\nmodule.exports = {\n  pattern: /some pattern/,\n  handler: function(info, next) {\n    // ...\n  },\n};\n```\n\n\n### webot.dialog(file1, _[file2, ...]_)\n\n增加对话规则\n\n```javascript\nwebot.dialog({\n  'hello': '哈哈哈',\n  'hi': ['好吧', '你好']\n});\n\n// or\nwebot.dialog('./rules/foo.js', './rules/bar.js');\n```\n\nIn `rules/foo.js`:\n\n```javascript\nmodule.exports = {\n  'hello': '哈哈哈',\n  'hi': ['好吧', '你好']\n};\n```\n\n#### 使用YAML\n\n你也可以在你的项目中 `require('js-yaml')` ，\n采用简洁的 yaml 语法来定义纯文本的对话规则：\n\nIn `package.json`:\n```javascript\n   \"dependencies\": {\n       ...\n     \"js-yaml\": \"~2.0.3\"\n       ...\n   }\n```\n\nIn your `app.js`:\n\n```javascript\nrequire('js-yaml');\n\nwebot.dialog('./rules/abc.yaml');\n```\n\nIn `rules/abc.yaml`:\n\n```yaml\n---\n# 直接回复\nhi: 'hi,I am robot'\n\n# 随机回复一个\nhello:\n  - 你好\n  - fine\n  - how are you\n\n# 匹配组替换\n/key (.*)/i: '你输入了: {1}, \\{1}这样写就不会被替换'\n\n# 也可以是一个rule定义；如果没有定义pattern，自动使用key\nyaml:\n  name: 'test_yaml_object'\n  handler: '这是一个yaml的object配置'\n```\n\n### webot.reset()\n\nReset all rules, so your can reload rules when app is running.\n\n\n### webot.watch(app, _[options]_)\n\nAdd serveral standard middlewares to an express app. Including:\n\n- **options.verify**:  to verify request. Default: always pass.\n- **options.parser**: to parse request post body. Default: use `req.body`.\n- **options.send**: to send reply. Default: use `res.json`.\n- **options.sessionStore**: the storage for webot sessions, just like express's cookieSession.\n- **options.path**: where to watch. Default: \"/\".\n- **options.prop**: `req` or `res`'s property name to attach parsed and replied data. Default: \"webot_data\".\n\nThe middleware layout would be:\n\n```javascript\n  app.get(path, verify);\n  app.post(path, verify, parser, function(req, res, next) {\n    webot.reply(req[prop], function(err, info) {\n      res[prop] = info;\n      next();\n    });\n  }, send);\n```\n\n## Rule(options)\n\n使用 `webot.set` 和 `webot.wait` 等方法时，会自动新建一条 rule ，\nrule 定义的具体可用参数如下：\n\n### options.name\n\n为规则命名，方便使用 `webot.get` 获取规则。\n\n### options.pattern\n\n消息匹配规则，用以判断是否对用户发送的消息进行回复。如果为正则表达式和字符串，\n则只匹配用户发送的文本消息（也就是 `info.text !== undefined` 的消息）。\n\n所有支持的格式：\n\n- {String}   如果是潜在的 RegExp （如字符串 '/abc/igm' ），会被转为 RegExp，如果以 '=' 打头，则完全匹配，否则模糊匹配\n- {RegExp}   正则表达式，匹配到的捕获组会被赋予 `info.param` ，可通过 `info.param[1]`, `info.param[2]`.. 获取\n- {Function} 该函数只接受一个参数 `info` ，返回布尔值\n- {NULL}     不指定 pattern ，则视为通过匹配，此 Rule 的 handler 将总是会执行\n\n示例：\n\n```javascript\n// 匹配下列所有消息：\n//\n//    你是机器人吗\n//    难道你是机器人？\n//    你是不是机器人？\n//    ...\n//\nwebot.set('Blur match', {\n  pattern: '是机器人',\n  handler: '是的，我就是一名光荣的机器人'\n});\n\n// 当字符串 pattern 以 \"=\" 开头时，则会完全匹配\nwebot.set('Exact match', {\n  pattern: '=a',\n  handler: '只有回复「a」时才会看到本消息'\n});\n\n// 利用正则来匹配\nwebot.set('your name', {\n  pattern: /^(?:my name is|i am|我(?:的名字)?(?:是|叫)?)\\s*(.*)$/i,\n  handler: function(info) {\n    return '你好，' + info.param[1];\n  },\n  // 或者直接返回字符串，webot 会自动替换匹配关键字\n  // handler: '你好，{1}'\n});\n\n// 类正则的字符串会被还原为正则\nwebot.set('/(good\\s*)morning/i', '早上好，先生');\n\n// 可以接受 function\nwebot.set('pattern as fn', {\n  pattern: function(info){\n    return info.param.eventKey === 'subscribe';\n  },\n  handler: '你好，欢迎关注我'\n});\n\n```\n\n### options.handler\n\n指定如何生成回复消息\n\n当返回非真值(null/false)时继续执行下一个动作，否则返回值会被回复给用户。\n\n支持的定义格式:\n\n- {String}    直接返回字符串\n- {Array}     从数组中随机取一个作为 handler\n- {Object}    直接返回\n- {Function}  执行函数获取返回值，第一个参数为消息请求的 info 对象\n\n支持异步：\n\n```javascript\n\nwebot.set('search_database', {\n  description: 'Search a keyword from database',\n  pattern: /^(?:s\\s+)(.+)$/i,\n  handler: function(info, next) {\n    // assert(this.name == 'search_database');\n    // 函数内的 this 变量即此规则\n\n    // 执行一个异步操作..\n    query_from_database(info.text, function(err, ret) {\n      if (err) return next(500);\n      return next(null, ret);\n    });\n  }\n});\n```\n\n在函数执行过程中，如果设置 `info.ended = true` ，即使没有返回可用的回复，也不会再继续下一条规则。\n此时会 fallback 到预设的 404 错误，参见 **webot.codeReplies**。\n\n\n**注意**：\n\n你是否注意到，`handler` 允许异步操作，而 `pattern` 却不可以？\n\n事实上，所有的 pattern 操作，都可以放到 `handler` 里执行：\n\n```javascript\nwebot.set('test_A', {\n  handler: function(info, next) {\n    if (info.text == 'A') {\n      next(null, 'You said A.');\n    }\n    next();\n  }\n});\n```\n\n或者更省略一点：\n\n```\nwebot.set(function test_A(info) {\n  if (info.text == 'A') {\n    return 'You said A.';\n  }\n});\n```\n\n所以，异步的匹配可以写成：\n\n```javascript\nwebot.set('test', {\n  handler: function(info, next) {\n    var uid = info.uid;\n    User.findOne(uid, function(err, doc) {\n      if (!doc) {\n        // 异步判断失败，进入下一条规则\n        return next();\n      }\n      // 判断成功后需要执行的操作在这里\n      return next(null, '欢迎你，' + doc.name);\n    });\n  }\n});\n```\n\n相信你并不会太需要在匹配消息规则时也进行异步。\n事实上，很多需求都可以转化为使用 `webot.beforeReply` 。\n\n\n### options.replies\n\n指定如何**再次回复用户的回复**。即用户回复了根据当前规则回复的消息后，如何继续对话。\n必须先配置 [session支持](#session-support)。\n\n```javascript\nwebot.set('guess my sex', {\n  pattern: /是男.还是女.|你.*男的女的/,\n  handler: '你猜猜看呐',\n  replies: {\n    '/女|girl/i': '人家才不是女人呢',\n    '/男|boy/i': '是的，我就是翩翩公子一枚',\n    'both|不男不女': '你丫才不男不女呢',\n    '不猜': '好的，再见',\n    '/.*/': function(info) {\n      // 在 replies 的 handler 里可以获得等待回复的重试次数参数\n      if (info.rewaitCount < 2) {\n        info.rewait();\n        return '你到底还猜不猜嘛！';\n      }\n      return '看来你真的不想猜啊';\n    },\n  }\n\n  // 也可以用一个函数搞定:\n  // replies: function(info){\n  //   return '嘻嘻，不告诉你'\n  // }\n\n  // 也可以是数组格式，每个元素为一条rule\n  // replies: [{\n  //   pattern: '/^g(irl)?\\\\??$/i',\n  //   handler: '猜错'\n  // },{\n  //   pattern: '/^b(oy)?\\\\??$/i',\n  //   handler: '猜对了'\n  // },{\n  //   pattern: 'both',\n  //   handler: '对你无语...'\n  // }]\n});\n```\n\n## Info\n\nRequest and response in one place, with session support enabled.\n\n### info.session\n\n当你在你的 express 中间件中为 `info` 加入了 `session` 支持，即可使用等待操作的高级功能。\n\n### info.wait(rule)\n\n等待用户回复。并根据 `rule` 定义来回复用户。\n`rule` 可以是一个 function 或 object。\n用法与 `webot.set` 的参数类似。\n\n### info.rewait()\n\n重试上次等待操作。一般在 `replies` 的 handler 里调用。\n\n以上两个方法均需要 session 支持。\n具体用法请参看[示例](https://github.com/node-webot/webot-example)。\n\n### info.err\n\nEach time we got an error from `rule.handler`, `info.err` will be updated. The last error will always stay there.\n\n## Session Support\n\nTODO: 待完善\n\n## 命令行工具\n\n提供可执行文件 `webot` 用于发送测试消息。\n使用 `npm` 安装 [webot-cli](https://github.com/node-webot/webot-cli)：\n\n    npm install webot-cli -g\n\nHave fun with wechat, and enjoy being a robot!\n\n## LICENSE\n\n(The MIT License)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the 'Software'), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/node-webot/webot/issues"
  },
  "homepage": "https://github.com/node-webot/webot",
  "_id": "webot@0.1.9",
  "_from": "webot@*"
}
